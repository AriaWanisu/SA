'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk2 = _interopDefault(require('chalk'));
var index = require('./index-dff1c82a.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var svgrTemplate = require('./svgrTemplate-2930b0e1.js');
var rollup = require('rollup');
var peerDepsExternal = _interopDefault(require('rollup-plugin-peer-deps-external'));
var commonjs = _interopDefault(require('@rollup/plugin-commonjs'));
var resolve = _interopDefault(require('@rollup/plugin-node-resolve'));
var postcss = _interopDefault(require('rollup-plugin-postcss'));
var esbuild = _interopDefault(require('rollup-plugin-esbuild'));
var svgr = _interopDefault(require('@svgr/rollup'));
var dts = _interopDefault(require('rollup-plugin-dts'));
var json = _interopDefault(require('@rollup/plugin-json'));
var yaml = _interopDefault(require('@rollup/plugin-yaml'));
var rollupPluginutils = require('rollup-pluginutils');

function forwardFileImports(options) {
  const filter = rollupPluginutils.createFilter(options.include, options.exclude);
  const exportedFiles = new Set();
  const generatedFor = new Set();
  return {
    name: "forward-file-imports",
    async generateBundle(outputOptions, bundle, isWrite) {
      if (!isWrite) {
        return;
      }
      const dir = outputOptions.dir || path2.dirname(outputOptions.file);
      if (generatedFor.has(dir)) {
        return;
      }
      for (const output of Object.values(bundle)) {
        if (output.type !== "chunk") {
          continue;
        }
        const chunk = output;
        if (!chunk.facadeModuleId) {
          continue;
        }
        generatedFor.add(dir);
        const srcRoot = path2.dirname(chunk.facadeModuleId);
        await Promise.all(Array.from(exportedFiles).map(async (exportedFile) => {
          const outputPath = path2.relative(srcRoot, exportedFile);
          const targetFile = path2.resolve(dir, outputPath);
          await fs.ensureDir(path2.dirname(targetFile));
          await fs.copyFile(exportedFile, targetFile);
        }));
        return;
      }
    },
    options(inputOptions) {
      const origExternal = inputOptions.external;
      const external = (id, importer, isResolved) => {
        if (typeof origExternal === "function" && origExternal(id, importer, isResolved)) {
          return true;
        }
        if (Array.isArray(origExternal) && origExternal.includes(id)) {
          return true;
        }
        if (!filter(id)) {
          return false;
        }
        if (!importer) {
          throw new Error(`Unknown importer of file module ${id}`);
        }
        const fullId = isResolved ? id : path2.resolve(path2.dirname(importer), id);
        exportedFiles.add(fullId);
        return true;
      };
      return {...inputOptions, external};
    }
  };
}

(function(Output2) {
  Output2[Output2["esm"] = 0] = "esm";
  Output2[Output2["cjs"] = 1] = "cjs";
  Output2[Output2["types"] = 2] = "types";
})(exports.Output || (exports.Output = {}));

const makeConfigs = async (options) => {
  const typesInput = index.paths.resolveTargetRoot("dist-types", path2.relative(index.paths.targetRoot, index.paths.targetDir), "src/index.d.ts");
  const declarationsExist = await fs.pathExists(typesInput);
  if (!declarationsExist) {
    const path2$1 = path2.relative(index.paths.targetDir, typesInput);
    throw new Error(`No declaration files found at ${path2$1}, be sure to run ${chalk2.bgRed.white("yarn tsc")} to generate .d.ts files before packaging`);
  }
  const configs = new Array();
  if (options.outputs.has(exports.Output.cjs) || options.outputs.has(exports.Output.esm)) {
    const output = new Array();
    const mainFields = ["module", "main"];
    if (options.outputs.has(exports.Output.cjs)) {
      output.push({
        dir: "dist",
        entryFileNames: "index.cjs.js",
        chunkFileNames: "cjs/[name]-[hash].js",
        format: "commonjs",
        sourcemap: true
      });
    }
    if (options.outputs.has(exports.Output.esm)) {
      output.push({
        dir: "dist",
        entryFileNames: "index.esm.js",
        chunkFileNames: "esm/[name]-[hash].js",
        format: "module",
        sourcemap: true
      });
      mainFields.unshift("browser");
    }
    configs.push({
      input: "src/index.ts",
      output,
      preserveEntrySignatures: "strict",
      external: require("module").builtinModules,
      plugins: [
        peerDepsExternal({
          includeDependencies: true
        }),
        resolve({mainFields}),
        commonjs({
          include: /node_modules/,
          exclude: [/\/[^/]+\.(?:stories|test)\.[^/]+$/]
        }),
        postcss(),
        forwardFileImports({
          exclude: /\.icon\.svg$/,
          include: [/\.svg$/, /\.png$/, /\.gif$/, /\.jpg$/, /\.jpeg$/]
        }),
        json(),
        yaml(),
        svgr({
          include: /\.icon\.svg$/,
          template: svgrTemplate.svgrTemplate
        }),
        esbuild({
          target: "es2019"
        })
      ]
    });
  }
  if (options.outputs.has(exports.Output.types)) {
    configs.push({
      input: typesInput,
      output: {
        file: "dist/index.d.ts",
        format: "es"
      },
      plugins: [dts()]
    });
  }
  return configs;
};

function formatErrorMessage(error) {
  let msg = "";
  if (error.code === "PLUGIN_ERROR") {
    if (error.plugin === "esbuild") {
      msg += `${error.message}

`;
      for (const {text, location} of error.errors) {
        const {line, column} = location;
        const path2$1 = path2.relative(index.paths.targetDir, error.id);
        const loc = chalk2.cyan(`${path2$1}:${line}:${column}`);
        if (text === 'Unexpected "<"' && error.id.endsWith(".js")) {
          msg += `${loc}: ${text}, JavaScript files with JSX should use a .jsx extension`;
        } else {
          msg += `${loc}: ${text}`;
        }
      }
    } else {
      msg += `(plugin ${error.plugin}) ${error}
`;
    }
  } else {
    if (error.loc) {
      const file = `${index.paths.resolveTarget(error.loc.file || error.id)}`;
      const pos = `${error.loc.line}:${error.loc.column}`;
      msg += `${file} [${pos}]
`;
    } else if (error.id) {
      msg += `${index.paths.resolveTarget(error.id)}
`;
    }
    msg += `${error}
`;
    if (error.url) {
      msg += `${chalk2.cyan(error.url)}
`;
    }
    if (error.frame) {
      msg += `${chalk2.dim(error.frame)}
`;
    }
  }
  return msg;
}
async function build(config2) {
  try {
    const bundle = await rollup.rollup(config2);
    if (config2.output) {
      for (const output of [config2.output].flat()) {
        await bundle.generate(output);
        await bundle.write(output);
      }
    }
  } catch (error) {
    throw new Error(formatErrorMessage(error));
  }
}
const buildPackage = async (options) => {
  const configs = await makeConfigs(options);
  await fs.remove(index.paths.resolveTarget("dist"));
  await Promise.all(configs.map(build));
};

exports.buildPackage = buildPackage;
//# sourceMappingURL=packager-dcd9eec8.js.map
