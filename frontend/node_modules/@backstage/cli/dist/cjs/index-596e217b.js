'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index-dff1c82a.js');
var fs = _interopDefault(require('fs-extra'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var run = require('./run-a8d49408.js');
var tar2 = _interopDefault(require('tar'));
var os2 = require('os');
var os2__default = _interopDefault(os2);

async function createDistWorkspace(packageNames, options = {}) {
  var _a, _b;
  const targetDir = (_a = options.targetDir) != null ? _a : await fs.mkdtemp(path2.resolve(os2.tmpdir(), "dist-workspace"));
  const targets = await findTargetPackages(packageNames);
  if (options.buildDependencies) {
    const scopeArgs = targets.flatMap((target) => ["--scope", target.name]);
    await run.run("yarn", ["lerna", "run", ...scopeArgs, "build"], {
      cwd: index.paths.targetRoot
    });
  }
  await moveToDistWorkspace(targetDir, targets);
  const files = (_b = options.files) != null ? _b : ["yarn.lock", "package.json"];
  for (const file of files) {
    const src = typeof file === "string" ? file : file.src;
    const dest = typeof file === "string" ? file : file.dest;
    await fs.copy(index.paths.resolveTargetRoot(src), path2.resolve(targetDir, dest));
  }
  if (options.skeleton) {
    const skeletonFiles = targets.map((target) => {
      const dir = path2.relative(index.paths.targetRoot, target.location);
      return path2.join(dir, "package.json");
    });
    await tar2.create({
      file: path2.resolve(targetDir, options.skeleton),
      cwd: targetDir,
      portable: true,
      noMtime: true
    }, skeletonFiles);
  }
  return targetDir;
}
async function moveToDistWorkspace(workspaceDir, localPackages) {
  await Promise.all(localPackages.map(async (target, index$1) => {
    console.log(`Repacking ${target.name} into dist workspace`);
    const archive = `temp-package-${index$1}.tgz`;
    const archivePath = path2.resolve(workspaceDir, archive);
    await run.run("yarn", ["pack", "--filename", archivePath], {
      cwd: target.location
    });
    if (target.scripts.postpack) {
      await run.run("yarn", ["postpack"], {cwd: target.location});
    }
    const outputDir = path2.relative(index.paths.targetRoot, target.location);
    const absoluteOutputPath = path2.resolve(workspaceDir, outputDir);
    await fs.ensureDir(absoluteOutputPath);
    await tar2.extract({
      file: archivePath,
      cwd: absoluteOutputPath,
      strip: 1
    });
    await fs.remove(archivePath);
    if (target.get("bundled")) {
      const pkgJson = await fs.readJson(path2.resolve(absoluteOutputPath, "package.json"));
      delete pkgJson.dependencies;
      delete pkgJson.devDependencies;
      delete pkgJson.peerDependencies;
      delete pkgJson.optionalDependencies;
      await fs.writeJson(path2.resolve(absoluteOutputPath, "package.json"), pkgJson, {
        spaces: 2
      });
    }
  }));
}
async function findTargetPackages(pkgNames) {
  var _a;
  const LernaProject = require("@lerna/project");
  const PackageGraph = require("@lerna/package-graph");
  const project = new LernaProject(index.paths.targetDir);
  const packages = await project.getPackages();
  const graph = new PackageGraph(packages);
  const targets = new Map();
  const searchNames = pkgNames.slice();
  while (searchNames.length) {
    const name = searchNames.pop();
    if (targets.has(name)) {
      continue;
    }
    const node = graph.get(name);
    if (!node) {
      throw new Error(`Package '${name}' not found`);
    }
    if (!node.pkg.get("bundled")) {
      const pkgDeps = Object.keys((_a = node.pkg.dependencies) != null ? _a : {});
      const localDeps = Array.from(node.localDependencies.keys());
      const filteredDeps = localDeps.filter((dep) => pkgDeps.includes(dep));
      searchNames.push(...filteredDeps);
    }
    targets.set(name, node.pkg);
  }
  return Array.from(targets.values());
}

exports.createDistWorkspace = createDistWorkspace;
//# sourceMappingURL=index-596e217b.js.map
