// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/ACER/app/ent/course"
	"github.com/ACER/app/ent/courseitem"
	"github.com/ACER/app/ent/subject"
	"github.com/ACER/app/ent/subjecttype"
	"github.com/ACER/app/ent/teacher"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse      = "Course"
	TypeCourseItem  = "CourseItem"
	TypeSubject     = "Subject"
	TypeSubjectType = "SubjectType"
	TypeTeacher     = "Teacher"
)

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	course_name         *string
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	course_items        map[int]struct{}
	removedcourse_items map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourseName sets the course_name field.
func (m *CourseMutation) SetCourseName(s string) {
	m.course_name = &s
}

// CourseName returns the course_name value in the mutation.
func (m *CourseMutation) CourseName() (r string, exists bool) {
	v := m.course_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseName returns the old course_name value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCourseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseName: %w", err)
	}
	return oldValue.CourseName, nil
}

// ResetCourseName reset all changes of the "course_name" field.
func (m *CourseMutation) ResetCourseName() {
	m.course_name = nil
}

// SetOwnerID sets the owner edge to Teacher by id.
func (m *CourseMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Teacher.
func (m *CourseMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *CourseMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *CourseMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *CourseMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCourseItemIDs adds the course_items edge to CourseItem by ids.
func (m *CourseMutation) AddCourseItemIDs(ids ...int) {
	if m.course_items == nil {
		m.course_items = make(map[int]struct{})
	}
	for i := range ids {
		m.course_items[ids[i]] = struct{}{}
	}
}

// RemoveCourseItemIDs removes the course_items edge to CourseItem by ids.
func (m *CourseMutation) RemoveCourseItemIDs(ids ...int) {
	if m.removedcourse_items == nil {
		m.removedcourse_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_items[ids[i]] = struct{}{}
	}
}

// RemovedCourseItems returns the removed ids of course_items.
func (m *CourseMutation) RemovedCourseItemsIDs() (ids []int) {
	for id := range m.removedcourse_items {
		ids = append(ids, id)
	}
	return
}

// CourseItemsIDs returns the course_items ids in the mutation.
func (m *CourseMutation) CourseItemsIDs() (ids []int) {
	for id := range m.course_items {
		ids = append(ids, id)
	}
	return
}

// ResetCourseItems reset all changes of the "course_items" edge.
func (m *CourseMutation) ResetCourseItems() {
	m.course_items = nil
	m.removedcourse_items = nil
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.course_name != nil {
		fields = append(fields, course.FieldCourseName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCourseName:
		return m.CourseName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCourseName:
		return m.OldCourseName(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCourseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseName(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCourseName:
		m.ResetCourseName()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, course.EdgeOwner)
	}
	if m.course_items != nil {
		edges = append(edges, course.EdgeCourseItems)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.course_items))
		for id := range m.course_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourse_items != nil {
		edges = append(edges, course.EdgeCourseItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.removedcourse_items))
		for id := range m.removedcourse_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, course.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ResetOwner()
		return nil
	case course.EdgeCourseItems:
		m.ResetCourseItems()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// CourseItemMutation represents an operation that mutate the CourseItems
// nodes in the graph.
type CourseItemMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clearedFields   map[string]struct{}
	courses         *int
	clearedcourses  bool
	subjects        *int
	clearedsubjects bool
	types           *int
	clearedtypes    bool
	done            bool
	oldValue        func(context.Context) (*CourseItem, error)
}

var _ ent.Mutation = (*CourseItemMutation)(nil)

// courseitemOption allows to manage the mutation configuration using functional options.
type courseitemOption func(*CourseItemMutation)

// newCourseItemMutation creates new mutation for $n.Name.
func newCourseItemMutation(c config, op Op, opts ...courseitemOption) *CourseItemMutation {
	m := &CourseItemMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseItemID sets the id field of the mutation.
func withCourseItemID(id int) courseitemOption {
	return func(m *CourseItemMutation) {
		var (
			err   error
			once  sync.Once
			value *CourseItem
		)
		m.oldValue = func(ctx context.Context) (*CourseItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourseItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseItem sets the old CourseItem of the mutation.
func withCourseItem(node *CourseItem) courseitemOption {
	return func(m *CourseItemMutation) {
		m.oldValue = func(context.Context) (*CourseItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCoursesID sets the courses edge to Course by id.
func (m *CourseItemMutation) SetCoursesID(id int) {
	m.courses = &id
}

// ClearCourses clears the courses edge to Course.
func (m *CourseItemMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared returns if the edge courses was cleared.
func (m *CourseItemMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// CoursesID returns the courses id in the mutation.
func (m *CourseItemMutation) CoursesID() (id int, exists bool) {
	if m.courses != nil {
		return *m.courses, true
	}
	return
}

// CoursesIDs returns the courses ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CoursesID instead. It exists only for internal usage by the builders.
func (m *CourseItemMutation) CoursesIDs() (ids []int) {
	if id := m.courses; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourses reset all changes of the "courses" edge.
func (m *CourseItemMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
}

// SetSubjectsID sets the subjects edge to Subject by id.
func (m *CourseItemMutation) SetSubjectsID(id int) {
	m.subjects = &id
}

// ClearSubjects clears the subjects edge to Subject.
func (m *CourseItemMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared returns if the edge subjects was cleared.
func (m *CourseItemMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// SubjectsID returns the subjects id in the mutation.
func (m *CourseItemMutation) SubjectsID() (id int, exists bool) {
	if m.subjects != nil {
		return *m.subjects, true
	}
	return
}

// SubjectsIDs returns the subjects ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubjectsID instead. It exists only for internal usage by the builders.
func (m *CourseItemMutation) SubjectsIDs() (ids []int) {
	if id := m.subjects; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjects reset all changes of the "subjects" edge.
func (m *CourseItemMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
}

// SetTypesID sets the types edge to SubjectType by id.
func (m *CourseItemMutation) SetTypesID(id int) {
	m.types = &id
}

// ClearTypes clears the types edge to SubjectType.
func (m *CourseItemMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared returns if the edge types was cleared.
func (m *CourseItemMutation) TypesCleared() bool {
	return m.clearedtypes
}

// TypesID returns the types id in the mutation.
func (m *CourseItemMutation) TypesID() (id int, exists bool) {
	if m.types != nil {
		return *m.types, true
	}
	return
}

// TypesIDs returns the types ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypesID instead. It exists only for internal usage by the builders.
func (m *CourseItemMutation) TypesIDs() (ids []int) {
	if id := m.types; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypes reset all changes of the "types" edge.
func (m *CourseItemMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
}

// Op returns the operation name.
func (m *CourseItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourseItem).
func (m *CourseItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseItemMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseItemMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CourseItem field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CourseItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseItemMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CourseItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CourseItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseItemMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CourseItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.courses != nil {
		edges = append(edges, courseitem.EdgeCourses)
	}
	if m.subjects != nil {
		edges = append(edges, courseitem.EdgeSubjects)
	}
	if m.types != nil {
		edges = append(edges, courseitem.EdgeTypes)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courseitem.EdgeCourses:
		if id := m.courses; id != nil {
			return []ent.Value{*id}
		}
	case courseitem.EdgeSubjects:
		if id := m.subjects; id != nil {
			return []ent.Value{*id}
		}
	case courseitem.EdgeTypes:
		if id := m.types; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourses {
		edges = append(edges, courseitem.EdgeCourses)
	}
	if m.clearedsubjects {
		edges = append(edges, courseitem.EdgeSubjects)
	}
	if m.clearedtypes {
		edges = append(edges, courseitem.EdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseItemMutation) EdgeCleared(name string) bool {
	switch name {
	case courseitem.EdgeCourses:
		return m.clearedcourses
	case courseitem.EdgeSubjects:
		return m.clearedsubjects
	case courseitem.EdgeTypes:
		return m.clearedtypes
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseItemMutation) ClearEdge(name string) error {
	switch name {
	case courseitem.EdgeCourses:
		m.ClearCourses()
		return nil
	case courseitem.EdgeSubjects:
		m.ClearSubjects()
		return nil
	case courseitem.EdgeTypes:
		m.ClearTypes()
		return nil
	}
	return fmt.Errorf("unknown CourseItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseItemMutation) ResetEdge(name string) error {
	switch name {
	case courseitem.EdgeCourses:
		m.ResetCourses()
		return nil
	case courseitem.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case courseitem.EdgeTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown CourseItem edge %s", name)
}

// SubjectMutation represents an operation that mutate the Subjects
// nodes in the graph.
type SubjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	subject_name        *string
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	course_items        map[int]struct{}
	removedcourse_items map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Subject, error)
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows to manage the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for $n.Name.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the id field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubjectName sets the subject_name field.
func (m *SubjectMutation) SetSubjectName(s string) {
	m.subject_name = &s
}

// SubjectName returns the subject_name value in the mutation.
func (m *SubjectMutation) SubjectName() (r string, exists bool) {
	v := m.subject_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectName returns the old subject_name value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldSubjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectName: %w", err)
	}
	return oldValue.SubjectName, nil
}

// ResetSubjectName reset all changes of the "subject_name" field.
func (m *SubjectMutation) ResetSubjectName() {
	m.subject_name = nil
}

// SetOwnerID sets the owner edge to Teacher by id.
func (m *SubjectMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Teacher.
func (m *SubjectMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *SubjectMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *SubjectMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SubjectMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *SubjectMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCourseItemIDs adds the course_items edge to CourseItem by ids.
func (m *SubjectMutation) AddCourseItemIDs(ids ...int) {
	if m.course_items == nil {
		m.course_items = make(map[int]struct{})
	}
	for i := range ids {
		m.course_items[ids[i]] = struct{}{}
	}
}

// RemoveCourseItemIDs removes the course_items edge to CourseItem by ids.
func (m *SubjectMutation) RemoveCourseItemIDs(ids ...int) {
	if m.removedcourse_items == nil {
		m.removedcourse_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_items[ids[i]] = struct{}{}
	}
}

// RemovedCourseItems returns the removed ids of course_items.
func (m *SubjectMutation) RemovedCourseItemsIDs() (ids []int) {
	for id := range m.removedcourse_items {
		ids = append(ids, id)
	}
	return
}

// CourseItemsIDs returns the course_items ids in the mutation.
func (m *SubjectMutation) CourseItemsIDs() (ids []int) {
	for id := range m.course_items {
		ids = append(ids, id)
	}
	return
}

// ResetCourseItems reset all changes of the "course_items" edge.
func (m *SubjectMutation) ResetCourseItems() {
	m.course_items = nil
	m.removedcourse_items = nil
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.subject_name != nil {
		fields = append(fields, subject.FieldSubjectName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldSubjectName:
		return m.SubjectName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldSubjectName:
		return m.OldSubjectName(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldSubjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectName(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldSubjectName:
		m.ResetSubjectName()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, subject.EdgeOwner)
	}
	if m.course_items != nil {
		edges = append(edges, subject.EdgeCourseItems)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case subject.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.course_items))
		for id := range m.course_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourse_items != nil {
		edges = append(edges, subject.EdgeCourseItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.removedcourse_items))
		for id := range m.removedcourse_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, subject.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	case subject.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeOwner:
		m.ResetOwner()
		return nil
	case subject.EdgeCourseItems:
		m.ResetCourseItems()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// SubjectTypeMutation represents an operation that mutate the SubjectTypes
// nodes in the graph.
type SubjectTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	type_name           *string
	clearedFields       map[string]struct{}
	course_items        map[int]struct{}
	removedcourse_items map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*SubjectType, error)
}

var _ ent.Mutation = (*SubjectTypeMutation)(nil)

// subjecttypeOption allows to manage the mutation configuration using functional options.
type subjecttypeOption func(*SubjectTypeMutation)

// newSubjectTypeMutation creates new mutation for $n.Name.
func newSubjectTypeMutation(c config, op Op, opts ...subjecttypeOption) *SubjectTypeMutation {
	m := &SubjectTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectTypeID sets the id field of the mutation.
func withSubjectTypeID(id int) subjecttypeOption {
	return func(m *SubjectTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectType
		)
		m.oldValue = func(ctx context.Context) (*SubjectType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectType sets the old SubjectType of the mutation.
func withSubjectType(node *SubjectType) subjecttypeOption {
	return func(m *SubjectTypeMutation) {
		m.oldValue = func(context.Context) (*SubjectType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeName sets the type_name field.
func (m *SubjectTypeMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the type_name value in the mutation.
func (m *SubjectTypeMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old type_name value of the SubjectType.
// If the SubjectType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectTypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "type_name" field.
func (m *SubjectTypeMutation) ResetTypeName() {
	m.type_name = nil
}

// AddCourseItemIDs adds the course_items edge to CourseItem by ids.
func (m *SubjectTypeMutation) AddCourseItemIDs(ids ...int) {
	if m.course_items == nil {
		m.course_items = make(map[int]struct{})
	}
	for i := range ids {
		m.course_items[ids[i]] = struct{}{}
	}
}

// RemoveCourseItemIDs removes the course_items edge to CourseItem by ids.
func (m *SubjectTypeMutation) RemoveCourseItemIDs(ids ...int) {
	if m.removedcourse_items == nil {
		m.removedcourse_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_items[ids[i]] = struct{}{}
	}
}

// RemovedCourseItems returns the removed ids of course_items.
func (m *SubjectTypeMutation) RemovedCourseItemsIDs() (ids []int) {
	for id := range m.removedcourse_items {
		ids = append(ids, id)
	}
	return
}

// CourseItemsIDs returns the course_items ids in the mutation.
func (m *SubjectTypeMutation) CourseItemsIDs() (ids []int) {
	for id := range m.course_items {
		ids = append(ids, id)
	}
	return
}

// ResetCourseItems reset all changes of the "course_items" edge.
func (m *SubjectTypeMutation) ResetCourseItems() {
	m.course_items = nil
	m.removedcourse_items = nil
}

// Op returns the operation name.
func (m *SubjectTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubjectType).
func (m *SubjectTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.type_name != nil {
		fields = append(fields, subjecttype.FieldTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subjecttype.FieldTypeName:
		return m.TypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subjecttype.FieldTypeName:
		return m.OldTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown SubjectType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subjecttype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown SubjectType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubjectType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectTypeMutation) ResetField(name string) error {
	switch name {
	case subjecttype.FieldTypeName:
		m.ResetTypeName()
		return nil
	}
	return fmt.Errorf("unknown SubjectType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course_items != nil {
		edges = append(edges, subjecttype.EdgeCourseItems)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjecttype.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.course_items))
		for id := range m.course_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourse_items != nil {
		edges = append(edges, subjecttype.EdgeCourseItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subjecttype.EdgeCourseItems:
		ids := make([]ent.Value, 0, len(m.removedcourse_items))
		for id := range m.removedcourse_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectTypeMutation) ResetEdge(name string) error {
	switch name {
	case subjecttype.EdgeCourseItems:
		m.ResetCourseItems()
		return nil
	}
	return fmt.Errorf("unknown SubjectType edge %s", name)
}

// TeacherMutation represents an operation that mutate the Teachers
// nodes in the graph.
type TeacherMutation struct {
	config
	op              Op
	typ             string
	id              *int
	teacher_email   *string
	teacher_name    *string
	clearedFields   map[string]struct{}
	subjects        map[int]struct{}
	removedsubjects map[int]struct{}
	courses         map[int]struct{}
	removedcourses  map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Teacher, error)
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows to manage the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for $n.Name.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the id field of the mutation.
func withTeacherID(id int) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTeacherEmail sets the teacher_email field.
func (m *TeacherMutation) SetTeacherEmail(s string) {
	m.teacher_email = &s
}

// TeacherEmail returns the teacher_email value in the mutation.
func (m *TeacherMutation) TeacherEmail() (r string, exists bool) {
	v := m.teacher_email
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherEmail returns the old teacher_email value of the Teacher.
// If the Teacher object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TeacherMutation) OldTeacherEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherEmail: %w", err)
	}
	return oldValue.TeacherEmail, nil
}

// ResetTeacherEmail reset all changes of the "teacher_email" field.
func (m *TeacherMutation) ResetTeacherEmail() {
	m.teacher_email = nil
}

// SetTeacherName sets the teacher_name field.
func (m *TeacherMutation) SetTeacherName(s string) {
	m.teacher_name = &s
}

// TeacherName returns the teacher_name value in the mutation.
func (m *TeacherMutation) TeacherName() (r string, exists bool) {
	v := m.teacher_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherName returns the old teacher_name value of the Teacher.
// If the Teacher object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TeacherMutation) OldTeacherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherName: %w", err)
	}
	return oldValue.TeacherName, nil
}

// ResetTeacherName reset all changes of the "teacher_name" field.
func (m *TeacherMutation) ResetTeacherName() {
	m.teacher_name = nil
}

// AddSubjectIDs adds the subjects edge to Subject by ids.
func (m *TeacherMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// RemoveSubjectIDs removes the subjects edge to Subject by ids.
func (m *TeacherMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed ids of subjects.
func (m *TeacherMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the subjects ids in the mutation.
func (m *TeacherMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects reset all changes of the "subjects" edge.
func (m *TeacherMutation) ResetSubjects() {
	m.subjects = nil
	m.removedsubjects = nil
}

// AddCourseIDs adds the courses edge to Course by ids.
func (m *TeacherMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// RemoveCourseIDs removes the courses edge to Course by ids.
func (m *TeacherMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed ids of courses.
func (m *TeacherMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the courses ids in the mutation.
func (m *TeacherMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses reset all changes of the "courses" edge.
func (m *TeacherMutation) ResetCourses() {
	m.courses = nil
	m.removedcourses = nil
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.teacher_email != nil {
		fields = append(fields, teacher.FieldTeacherEmail)
	}
	if m.teacher_name != nil {
		fields = append(fields, teacher.FieldTeacherName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldTeacherEmail:
		return m.TeacherEmail()
	case teacher.FieldTeacherName:
		return m.TeacherName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldTeacherEmail:
		return m.OldTeacherEmail(ctx)
	case teacher.FieldTeacherName:
		return m.OldTeacherName(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldTeacherEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherEmail(v)
		return nil
	case teacher.FieldTeacherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherName(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TeacherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TeacherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldTeacherEmail:
		m.ResetTeacherEmail()
		return nil
	case teacher.FieldTeacherName:
		m.ResetTeacherName()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subjects != nil {
		edges = append(edges, teacher.EdgeSubjects)
	}
	if m.courses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubjects != nil {
		edges = append(edges, teacher.EdgeSubjects)
	}
	if m.removedcourses != nil {
		edges = append(edges, teacher.EdgeCourses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case teacher.EdgeCourses:
		m.ResetCourses()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}
